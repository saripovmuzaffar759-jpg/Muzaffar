<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MUZAFFAR Шахматы - Онлайн</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #00ffc8;
            --secondary-color: #00aaff;
            --accent-color: #ff00aa;
            --bg-color: #0a0a15;
            --card-bg: rgba(20, 20, 35, 0.9);
            --text-primary: #ffffff;
            --text-secondary: #b0b0ff;
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --piece-white: #ffffff;
            --piece-black: #000000;
            --gradient: linear-gradient(45deg, var(--primary-color), var(--secondary-color), var(--accent-color));
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 200, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(0, 170, 255, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(255, 0, 170, 0.05) 0%, transparent 50%);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(15, 15, 30, 0.8);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 200, 0.2);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5em;
            font-weight: 900;
            margin-bottom: 10px;
            background: var(--gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 255, 200, 0.3);
        }
        
        .tagline {
            font-size: 1.3em;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            background: rgba(15, 15, 30, 0.9);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(0, 255, 200, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .chessboard-panel {
            background: rgba(15, 15, 30, 0.9);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(0, 255, 200, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .info-panel {
            background: rgba(15, 15, 30, 0.9);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(0, 255, 200, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .section-title {
            font-size: 1.4em;
            margin-bottom: 20px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 255, 200, 0.2);
        }
        
        .game-modes {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .mode-btn {
            padding: 18px;
            background: rgba(30, 30, 50, 0.7);
            border: 1px solid rgba(0, 255, 200, 0.2);
            border-radius: 12px;
            color: var(--text-primary);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 8px;
            text-align: left;
        }
        
        .mode-btn:hover {
            background: rgba(0, 255, 200, 0.1);
            border-color: var(--primary-color);
            transform: translateY(-3px);
        }
        
        .mode-btn.active {
            background: rgba(0, 255, 200, 0.2);
            border-color: var(--primary-color);
            color: var(--primary-color);
            box-shadow: 0 5px 15px rgba(0, 255, 200, 0.2);
        }
        
        .mode-title {
            font-weight: 600;
            font-size: 1.1em;
            color: var(--primary-color);
        }
        
        .mode-desc {
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        
        .difficulty-selector {
            margin: 20px 0;
        }
        
        .difficulty-btns {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .difficulty-btn {
            padding: 12px;
            background: rgba(30, 30, 50, 0.7);
            border: 1px solid rgba(0, 255, 200, 0.2);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .difficulty-btn.active {
            background: rgba(0, 255, 200, 0.2);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .btn {
            width: 100%;
            padding: 16px;
            background: var(--gradient);
            border: none;
            border-radius: 12px;
            color: var(--bg-color);
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 255, 200, 0.4);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .chessboard {
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1 / 1;
            border: 3px solid var(--primary-color);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            margin-bottom: 25px;
            position: relative;
        }
        
        .board-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
        }
        
        .square {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .square.light {
            background-color: var(--light-square);
        }
        
        .square.dark {
            background-color: var(--dark-square);
        }
        
        .square.selected {
            box-shadow: inset 0 0 0 3px var(--primary-color);
            z-index: 2;
        }
        
        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: rgba(0, 255, 200, 0.7);
            border-radius: 50%;
            z-index: 1;
        }
        
        .square.capture-move::after {
            content: '';
            position: absolute;
            width: 85%;
            height: 85%;
            border: 3px solid var(--accent-color);
            border-radius: 50%;
            z-index: 1;
        }
        
        .square.last-move {
            background: rgba(0, 255, 200, 0.3) !important;
        }
        
        .piece {
            width: 85%;
            height: 85%;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 2;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        
        .piece.dragging {
            transform: scale(1.1);
            z-index: 10;
        }
        
        .piece.white { 
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
            color: var(--piece-white);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .piece.black { 
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
            color: var(--piece-black);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        
        .coordinates {
            position: absolute;
            font-size: 14px;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.7);
            pointer-events: none;
            z-index: 1;
        }
        
        .coordinate-file {
            bottom: 2px;
            right: 4px;
        }
        
        .coordinate-rank {
            top: 2px;
            left: 4px;
        }
        
        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
        }
        
        .player-info {
            padding: 20px;
            background: rgba(30, 30, 50, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 200, 0.2);
            text-align: center;
        }
        
        .player-info.active {
            border-color: var(--primary-color);
            background: rgba(0, 255, 200, 0.1);
        }
        
        .player-name {
            font-weight: 600;
            font-size: 1.2em;
            margin-bottom: 10px;
            color: var(--primary-color);
        }
        
        .player-time {
            font-size: 2em;
            font-weight: 700;
            font-family: monospace;
            color: var(--text-primary);
        }
        
        .player-time.low {
            color: var(--accent-color);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .move-list {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(30, 30, 50, 0.7);
            border-radius: 12px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid rgba(0, 255, 200, 0.2);
        }
        
        .move-list-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .moves-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .move-item {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-family: monospace;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .move-item:hover {
            background: rgba(0, 255, 200, 0.1);
        }
        
        .move-item.current {
            background: rgba(0, 255, 200, 0.2);
            border: 1px solid var(--primary-color);
        }
        
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 15px;
            min-height: 40px;
        }
        
        .captured-piece {
            width: 30px;
            height: 30px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.7;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }
        
        .captured-piece.white {
            color: var(--piece-white);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .captured-piece.black {
            color: var(--piece-black);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        
        .status-message {
            padding: 15px;
            background: rgba(30, 30, 50, 0.7);
            border-radius: 12px;
            margin-top: 20px;
            border: 1px solid rgba(0, 255, 200, 0.2);
            text-align: center;
            font-size: 1.1em;
        }
        
        .status-message.check {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
            color: #ffaa00;
        }
        
        .status-message.checkmate {
            border-color: var(--accent-color);
            background: rgba(255, 0, 170, 0.1);
            color: var(--accent-color);
        }
        
        .status-message.stalemate {
            border-color: #aaaaaa;
            background: rgba(170, 170, 170, 0.1);
            color: #aaaaaa;
        }
        
        .game-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        
        .control-btn {
            padding: 12px;
            background: rgba(30, 30, 50, 0.7);
            border: 1px solid rgba(0, 255, 200, 0.2);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .control-btn:hover {
            background: rgba(0, 255, 200, 0.1);
            border-color: var(--primary-color);
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 20px 30px;
            background: rgba(20, 20, 35, 0.95);
            border-left: 5px solid var(--primary-color);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            transform: translateX(150%);
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            z-index: 1000;
            max-width: 350px;
            backdrop-filter: blur(10px);
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.error {
            border-left-color: var(--accent-color);
        }
        
        .notification.success {
            border-left-color: var(--primary-color);
        }
        
        .notification.info {
            border-left-color: var(--secondary-color);
        }
        
        .room-code {
            background: rgba(0, 255, 200, 0.1);
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-family: monospace;
            font-size: 1.5em;
            letter-spacing: 3px;
            color: var(--primary-color);
        }
        
        .share-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .share-btn {
            flex: 1;
            padding: 12px;
            background: rgba(30, 30, 50, 0.7);
            border: 1px solid rgba(0, 255, 200, 0.2);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .promotion-modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 35, 0.95);
            border: 2px solid var(--primary-color);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .promotion-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .promotion-piece {
            width: 60px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: pointer;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            font-weight: bold;
        }
        
        .promotion-piece:hover {
            border-color: var(--primary-color);
            transform: scale(1.1);
        }
        
        .promotion-piece.white {
            color: var(--piece-white);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .promotion-piece.black {
            color: var(--piece-black);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        
        footer {
            text-align: center;
            padding: 30px;
            color: var(--text-secondary);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 40px;
            background: rgba(15, 15, 30, 0.8);
            border-radius: 20px;
        }
        
        footer a {
            color: var(--primary-color);
            text-decoration: none;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        footer a:hover {
            text-decoration: underline;
            text-shadow: 0 0 10px rgba(0, 255, 200, 0.5);
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .chessboard {
                max-width: 100%;
            }
            
            .game-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">MUZAFFAR ШАХМАТЫ</div>
            <div class="tagline">Играй против AI или с друзьями онлайн</div>
        </div>
        
        <div class="main-content">
            <div class="control-panel">
                <h2 class="section-title"><i class="fas fa-cog"></i> Настройки игры</h2>
                
                <div class="game-modes">
                    <div class="mode-btn active" data-mode="ai">
                        <div class="mode-title">Против компьютера</div>
                        <div class="mode-desc">Играйте против AI разных уровней сложности</div>
                    </div>
                    <div class="mode-btn" data-mode="local">
                        <div class="mode-title">Два игрока</div>
                        <div class="mode-desc">Играйте на одном устройстве по очереди</div>
                    </div>
                    <div class="mode-btn" data-mode="online">
                        <div class="mode-title">Онлайн игра</div>
                        <div class="mode-desc">Создайте комнату и пригласите друга</div>
                    </div>
                </div>
                
                <div class="difficulty-selector">
                    <label style="color: var(--text-secondary); display: block; margin-bottom: 10px;">
                        <i class="fas fa-brain"></i> Сложность AI:
                    </label>
                    <div class="difficulty-btns">
                        <div class="difficulty-btn active" data-level="1">Легко</div>
                        <div class="difficulty-btn" data-level="2">Средне</div>
                        <div class="difficulty-btn" data-level="3">Сложно</div>
                    </div>
                </div>
                
                <div class="time-control">
                    <label style="color: var(--text-secondary); display: block; margin: 20px 0 10px;">
                        <i class="fas fa-clock"></i> Контроль времени:
                    </label>
                    <select id="timeControl" style="width: 100%; padding: 12px; background: rgba(30,30,50,0.7); border: 1px solid rgba(0,255,200,0.3); border-radius: 8px; color: var(--text-primary);">
                        <option value="600">10 минут</option>
                        <option value="300">5 минут</option>
                        <option value="180">3 минуты</option>
                        <option value="60">1 минута</option>
                        <option value="0">Без времени</option>
                    </select>
                </div>
                
                <div class="color-selector">
                    <label style="color: var(--text-secondary); display: block; margin: 20px 0 10px;">
                        <i class="fas fa-chess-board"></i> Ваш цвет:
                    </label>
                    <div style="display: flex; gap: 10px;">
                        <div class="difficulty-btn active" data-color="white">Белые</div>
                        <div class="difficulty-btn" data-color="black">Чёрные</div>
                        <div class="difficulty-btn" data-color="random">Случайный</div>
                    </div>
                </div>
                
                <button id="startGame" class="btn">
                    <i class="fas fa-play"></i> Начать игру
                </button>
                
                <button id="newGame" class="btn" style="margin-top: 10px; background: rgba(30,30,50,0.7); color: var(--text-primary); border: 1px solid rgba(0,255,200,0.3);">
                    <i class="fas fa-redo"></i> Новая игра
                </button>
                
                <div style="margin-top: 30px; padding: 15px; background: rgba(0,255,200,0.05); border-radius: 12px; border: 1px solid rgba(0,255,200,0.2);">
                    <h4 style="color: var(--primary-color); margin-bottom: 10px;">Управление:</h4>
                    <ul style="color: var(--text-secondary); font-size: 0.9em; padding-left: 20px;">
                        <li>Кликните по фигуре для выбора</li>
                        <li>Кликните на клетку для хода</li>
                        <li>Перетаскивайте фигуры мышью</li>
                        <li>ПКМ - отменить выбор</li>
                    </ul>
                </div>
            </div>
            
            <div class="chessboard-panel">
                <h2 class="section-title"><i class="fas fa-chess-board"></i> Шахматная доска</h2>
                
                <div class="chessboard" id="chessboard">
                    <div class="board-grid" id="boardGrid"></div>
                </div>
                
                <div class="game-info">
                    <div class="player-info" id="whitePlayer">
                        <div class="player-name">Белые (Вы)</div>
                        <div class="player-time" id="whiteTime">10:00</div>
                        <div class="captured-pieces" id="whiteCaptured"></div>
                    </div>
                    
                    <div class="player-info" id="blackPlayer">
                        <div class="player-name">Чёрные (AI)</div>
                        <div class="player-time" id="blackTime">10:00</div>
                        <div class="captured-pieces" id="blackCaptured"></div>
                    </div>
                </div>
                
                <div class="status-message" id="statusMessage">
                    Начните игру, выбрав режим слева
                </div>
                
                <div class="game-controls">
                    <button class="control-btn" id="undoBtn">
                        <i class="fas fa-undo"></i> Назад
                    </button>
                    <button class="control-btn" id="hintBtn">
                        <i class="fas fa-lightbulb"></i> Подсказка
                    </button>
                    <button class="control-btn" id="flipBtn">
                        <i class="fas fa-sync-alt"></i> Повернуть
                    </button>
                </div>
            </div>
            
            <div class="info-panel">
                <h2 class="section-title"><i class="fas fa-info-circle"></i> Информация</h2>
                
                <div class="move-list">
                    <div class="move-list-header">
                        <span>Ход</span>
                        <span>Белые - Чёрные</span>
                    </div>
                    <div class="moves-container" id="movesContainer"></div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3 style="color: var(--primary-color); margin-bottom: 10px;">Статистика игры:</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div style="padding: 12px; background: rgba(30,30,50,0.7); border-radius: 8px; text-align: center;">
                            <div style="color: var(--text-secondary); font-size: 0.9em;">Ход</div>
                            <div style="font-size: 1.2em; font-weight: 600; color: var(--primary-color);" id="currentTurn">1</div>
                        </div>
                        <div style="padding: 12px; background: rgba(30,30,50,0.7); border-radius: 8px; text-align: center;">
                            <div style="color: var(--text-secondary); font-size: 0.9em;">Игрок</div>
                            <div style="font-size: 1.2em; font-weight: 600; color: var(--text-primary);" id="currentPlayer">Белые</div>
                        </div>
                    </div>
                </div>
                
                <div id="onlinePanel" style="display: none; margin-top: 20px;">
                    <h3 style="color: var(--primary-color); margin-bottom: 10px;">Онлайн комната</h3>
                    <div class="room-code" id="roomCode">ABCD-1234</div>
                    <div class="share-buttons">
                        <button class="share-btn" id="copyRoomCode">
                            <i class="fas fa-copy"></i> Копировать
                        </button>
                        <button class="share-btn" id="shareRoom">
                            <i class="fas fa-share-alt"></i> Поделиться
                        </button>
                    </div>
                    <div style="margin-top: 15px; padding: 12px; background: rgba(30,30,50,0.7); border-radius: 8px; text-align: center;">
                        <div style="color: var(--text-secondary);">Ожидание соперника...</div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(0,255,200,0.05); border-radius: 12px; border: 1px solid rgba(0,255,200,0.2);">
                    <h4 style="color: var(--primary-color); margin-bottom: 10px;">Обучение:</h4>
                    <div style="color: var(--text-secondary); font-size: 0.9em;">
                        <p>♔ Король - ходит на одну клетку в любом направлении</p>
                        <p>♕ Ферзь - ходит по диагонали, горизонтали и вертикали</p>
                        <p>♖ Ладья - ходит по горизонтали и вертикали</p>
                        <p>♗ Слон - ходит по диагонали</p>
                        <p>♘ Конь - ходит буквой "Г"</p>
                        <p>♙ Пешка - ходит вперёд, бьёт по диагонали</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="promotion-modal" id="promotionModal">
            <div style="text-align: center; margin-bottom: 15px; color: var(--primary-color); font-weight: 600;">
                Выберите фигуру для превращения пешки:
            </div>
            <div class="promotion-options" id="promotionOptions">
                <!-- Будет заполнено динамически -->
            </div>
        </div>
        
        <footer>
            <p>Основатель Шарипов Музаффар Анварович © 2025 | <a href="https://mrworld819.github.io/4/">О нас</a></p>
            <p style="margin-top: 10px; font-size: 0.9em;">
                <i class="fas fa-chess"></i> Полноценные шахматы | 
                <i class="fas fa-robot"></i> AI противник | 
                <i class="fas fa-wifi"></i> Онлайн игра
            </p>
        </footer>
    </div>
    
    <div class="notification" id="notification"></div>
    
    <script>
        // Шахматный движок
        class ChessEngine {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.validMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.gameState = 'idle'; // idle, playing, checkmate, stalemate, draw
                this.flipped = false;
                
                // Права на рокировку
                this.castlingRights = {
                    white: { king: true, queenside: true, kingside: true },
                    black: { king: true, queenside: true, kingside: true }
                };
                
                // Для отслеживания en passant
                this.enPassantSquare = null;
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
            }
            
            createInitialBoard() {
                // Создаём пустую доску 8x8
                const board = Array(8).fill().map(() => Array(8).fill(null));
                
                // Расставляем чёрные фигуры
                board[0][0] = { type: 'r', color: 'black' };
                board[0][1] = { type: 'n', color: 'black' };
                board[0][2] = { type: 'b', color: 'black' };
                board[0][3] = { type: 'q', color: 'black' };
                board[0][4] = { type: 'k', color: 'black' };
                board[0][5] = { type: 'b', color: 'black' };
                board[0][6] = { type: 'n', color: 'black' };
                board[0][7] = { type: 'r', color: 'black' };
                
                // Чёрные пешки
                for (let i = 0; i < 8; i++) {
                    board[1][i] = { type: 'p', color: 'black' };
                }
                
                // Белые пешки
                for (let i = 0; i < 8; i++) {
                    board[6][i] = { type: 'p', color: 'white' };
                }
                
                // Белые фигуры
                board[7][0] = { type: 'r', color: 'white' };
                board[7][1] = { type: 'n', color: 'white' };
                board[7][2] = { type: 'b', color: 'white' };
                board[7][3] = { type: 'q', color: 'white' };
                board[7][4] = { type: 'k', color: 'white' };
                board[7][5] = { type: 'b', color: 'white' };
                board[7][6] = { type: 'n', color: 'white' };
                board[7][7] = { type: 'r', color: 'white' };
                
                return board;
            }
            
            getPieceSymbol(piece) {
                const symbols = {
                    'k': '♔', 'q': '♕', 'r': '♖', 'b': '♗', 'n': '♘', 'p': '♙'
                };
                
                if (piece.color === 'black') {
                    // Чёрные фигуры - чёрные символы
                    const blackSymbols = {
                        'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
                    };
                    return blackSymbols[piece.type] || '?';
                }
                
                // Белые фигуры - белые символы
                return symbols[piece.type] || '?';
            }
            
            getPieceColorClass(piece) {
                return piece.color === 'white' ? 'white' : 'black';
            }
            
            selectSquare(row, col) {
                const piece = this.board[row][col];
                
                // Если уже выбрана клетка
                if (this.selectedSquare) {
                    const [selectedRow, selectedCol] = this.selectedSquare;
                    
                    // Если кликнули на валидный ход
                    if (this.isValidMove(selectedRow, selectedCol, row, col)) {
                        this.makeMove(selectedRow, selectedCol, row, col);
                        this.selectedSquare = null;
                        this.validMoves = [];
                        return true;
                    }
                    
                    // Если кликнули на другую свою фигуру
                    if (piece && piece.color === this.currentPlayer) {
                        this.selectedSquare = [row, col];
                        this.validMoves = this.getValidMoves(row, col);
                        return false;
                    }
                    
                    // Отмена выбора
                    this.selectedSquare = null;
                    this.validMoves = [];
                    return false;
                }
                
                // Если выбрали свою фигуру
                if (piece && piece.color === this.currentPlayer) {
                    this.selectedSquare = [row, col];
                    this.validMoves = this.getValidMoves(row, col);
                    return false;
                }
                
                return false;
            }
            
            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const moves = [];
                
                switch (piece.type) {
                    case 'p': // Пешка
                        moves.push(...this.getPawnMoves(row, col, piece.color));
                        break;
                    case 'n': // Конь
                        moves.push(...this.getKnightMoves(row, col, piece.color));
                        break;
                    case 'b': // Слон
                        moves.push(...this.getBishopMoves(row, col, piece.color));
                        break;
                    case 'r': // Ладья
                        moves.push(...this.getRookMoves(row, col, piece.color));
                        break;
                    case 'q': // Ферзь
                        moves.push(...this.getQueenMoves(row, col, piece.color));
                        break;
                    case 'k': // Король
                        moves.push(...this.getKingMoves(row, col, piece.color));
                        break;
                }
                
                // Фильтруем ходы, которые оставляют короля под шахом
                return moves.filter(move => {
                    const [toRow, toCol] = move;
                    return !this.moveExposesKing(row, col, toRow, toCol, piece.color);
                });
            }
            
            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Ход вперёд на одну клетку
                if (this.isValidSquare(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push([row + direction, col]);
                    
                    // Ход вперёд на две клетки с начальной позиции
                    if (row === startRow && !this.board[row + 2 * direction][col]) {
                        moves.push([row + 2 * direction, col]);
                    }
                }
                
                // Взятия
                const captureDirections = [[direction, -1], [direction, 1]];
                for (const [dRow, dCol] of captureDirections) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    
                    if (this.isValidSquare(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        
                        // Обычное взятие
                        if (targetPiece && targetPiece.color !== color) {
                            moves.push([newRow, newCol]);
                        }
                        
                        // Взятие на проходе
                        if (this.enPassantSquare && 
                            newRow === this.enPassantSquare[0] && 
                            newCol === this.enPassantSquare[1]) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
                
                return moves;
            }
            
            getKnightMoves(row, col, color) {
                const moves = [];
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                
                for (const [dRow, dCol] of knightMoves) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    
                    if (this.isValidSquare(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== color) {
                            moves.push([newRow, newCol]);
                        }
                    }
                }
                
                return moves;
            }
            
            getBishopMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [
                    [-1, -1], [-1, 1], [1, -1], [1, 1]
                ]);
            }
            
            getRookMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [
                    [-1, 0], [1, 0], [0, -1], [0, 1]
                ]);
            }
            
            getQueenMoves(row, col, color) {
                return [
                    ...this.getBishopMoves(row, col, color),
                    ...this.getRookMoves(row, col, color)
                ];
            }
            
            getKingMoves(row, col, color) {
                const moves = [];
                const kingMoves = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];
                
                for (const [dRow, dCol] of kingMoves) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    
                    if (this.isValidSquare(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== color) {
                            // Проверяем, не находится ли клетка под атакой
                            if (!this.isSquareAttacked(newRow, newCol, color)) {
                                moves.push([newRow, newCol]);
                            }
                        }
                    }
                }
                
                // Рокировка
                moves.push(...this.getCastlingMoves(row, col, color));
                
                return moves;
            }
            
            getSlidingMoves(row, col, color, directions) {
                const moves = [];
                
                for (const [dRow, dCol] of directions) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    
                    while (this.isValidSquare(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        
                        if (!targetPiece) {
                            moves.push([newRow, newCol]);
                        } else {
                            if (targetPiece.color !== color) {
                                moves.push([newRow, newCol]);
                            }
                            break;
                        }
                        
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                
                return moves;
            }
            
            getCastlingMoves(row, col, color) {
                const moves = [];
                const castling = this.castlingRights[color];
                
                if (!castling.king) return moves;
                
                // Короткая рокировка (kingside)
                if (castling.kingside) {
                    let canCastle = true;
                    
                    // Проверяем, свободны ли клетки между королём и ладьёй
                    for (let c = col + 1; c <= 6; c++) {
                        if (this.board[row][c]) {
                            canCastle = false;
                            break;
                        }
                    }
                    
                    // Проверяем, не проходятся ли клетки через шах
                    if (canCastle) {
                        for (let c = col; c <= col + 2; c++) {
                            if (this.isSquareAttacked(row, c, color)) {
                                canCastle = false;
                                break;
                            }
                        }
                    }
                    
                    if (canCastle) {
                        moves.push([row, col + 2]);
                    }
                }
                
                // Длинная рокировка (queenside)
                if (castling.queenside) {
                    let canCastle = true;
                    
                    // Проверяем, свободны ли клетки между королём и ладьёй
                    for (let c = col - 1; c >= 1; c--) {
                        if (this.board[row][c]) {
                            canCastle = false;
                            break;
                        }
                    }
                    
                    // Проверяем, не проходятся ли клетки через шах
                    if (canCastle) {
                        for (let c = col; c >= col - 2; c--) {
                            if (this.isSquareAttacked(row, c, color)) {
                                canCastle = false;
                                break;
                            }
                        }
                    }
                    
                    if (canCastle) {
                        moves.push([row, col - 2]);
                    }
                }
                
                return moves;
            }
            
            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            isValidMove(fromRow, fromCol, toRow, toCol) {
                return this.validMoves.some(move => 
                    move[0] === toRow && move[1] === toCol
                );
            }
            
            moveExposesKing(fromRow, fromCol, toRow, toCol, color) {
                // Сохраняем текущее состояние
                const originalPiece = this.board[toRow][toCol];
                const movingPiece = this.board[fromRow][fromCol];
                
                // Делаем временный ход
                this.board[toRow][toCol] = movingPiece;
                this.board[fromRow][fromCol] = null;
                
                // Находим позицию короля
                let kingRow, kingCol;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.type === 'k' && piece.color === color) {
                            kingRow = r;
                            kingCol = c;
                            break;
                        }
                    }
                }
                
                // Проверяем, находится ли король под шахом
                const inCheck = this.isSquareAttacked(kingRow, kingCol, color);
                
                // Возвращаем фигуры на место
                this.board[fromRow][fromCol] = movingPiece;
                this.board[toRow][toCol] = originalPiece;
                
                return inCheck;
            }
            
            isSquareAttacked(row, col, defenderColor) {
                const attackerColor = defenderColor === 'white' ? 'black' : 'white';
                
                // Проверяем все фигуры атакующего цвета
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.color === attackerColor) {
                            const moves = this.getAttackingMoves(r, c, piece);
                            if (moves.some(([mr, mc]) => mr === row && mc === col)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            getAttackingMoves(row, col, piece) {
                // Упрощённая версия без проверки шаха
                switch (piece.type) {
                    case 'p':
                        return this.getPawnAttacks(row, col, piece.color);
                    case 'n':
                        return this.getKnightMoves(row, col, piece.color);
                    case 'b':
                        return this.getBishopMoves(row, col, piece.color);
                    case 'r':
                        return this.getRookMoves(row, col, piece.color);
                    case 'q':
                        return this.getQueenMoves(row, col, piece.color);
                    case 'k':
                        return this.getKingAttacks(row, col, piece.color);
                    default:
                        return [];
                }
            }
            
            getPawnAttacks(row, col, color) {
                const attacks = [];
                const direction = color === 'white' ? -1 : 1;
                const attackDirections = [[direction, -1], [direction, 1]];
                
                for (const [dRow, dCol] of attackDirections) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    
                    if (this.isValidSquare(newRow, newCol)) {
                        attacks.push([newRow, newCol]);
                    }
                }
                
                return attacks;
            }
            
            getKingAttacks(row, col, color) {
                const attacks = [];
                const kingMoves = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];
                
                for (const [dRow, dCol] of kingMoves) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    
                    if (this.isValidSquare(newRow, newCol)) {
                        attacks.push([newRow, newCol]);
                    }
                }
                
                return attacks;
            }
            
            makeMove(fromRow, fromCol, toRow, toCol, promotion = null) {
                const piece = this.board[fromRow][fromCol];
                if (!piece) return false;
                
                const capturedPiece = this.board[toRow][toCol];
                
                // Запоминаем ход для истории
                const move = {
                    from: [fromRow, fromCol],
                    to: [toRow, toCol],
                    piece: { ...piece },
                    captured: capturedPiece ? { ...capturedPiece } : null,
                    promotion: promotion,
                    castling: false,
                    enPassant: false,
                    check: false,
                    mate: false
                };
                
                // Обработка взятия на проходе
                if (piece.type === 'p' && this.enPassantSquare && 
                    toRow === this.enPassantSquare[0] && toCol === this.enPassantSquare[1]) {
                    const capturedPawnRow = fromRow;
                    const capturedPawnCol = toCol;
                    const capturedPawn = this.board[capturedPawnRow][capturedPawnCol];
                    
                    if (capturedPawn) {
                        move.captured = { ...capturedPawn };
                        move.enPassant = true;
                        this.board[capturedPawnRow][capturedPawnCol] = null;
                        
                        if (piece.color === 'white') {
                            this.capturedPieces.black.push(capturedPawn);
                        } else {
                            this.capturedPieces.white.push(capturedPawn);
                        }
                    }
                }
                
                // Обработка рокировки
                if (piece.type === 'k' && Math.abs(toCol - fromCol) === 2) {
                    move.castling = true;
                    
                    // Перемещаем ладью
                    if (toCol > fromCol) { // Короткая рокировка
                        this.board[toRow][7] = null;
                        this.board[toRow][5] = { type: 'r', color: piece.color };
                    } else { // Длинная рокировка
                        this.board[toRow][0] = null;
                        this.board[toRow][3] = { type: 'r', color: piece.color };
                    }
                    
                    // Обновляем права на рокировку
                    this.castlingRights[piece.color].king = false;
                    this.castlingRights[piece.color].queenside = false;
                    this.castlingRights[piece.color].kingside = false;
                }
                
                // Обычное перемещение
                if (!move.castling) {
                    this.board[toRow][toCol] = piece;
                    this.board[fromRow][fromCol] = null;
                }
                
                // Превращение пешки
                if (piece.type === 'p' && (toRow === 0 || toRow === 7)) {
                    const promotedPiece = promotion || 'q';
                    this.board[toRow][toCol] = { type: promotedPiece, color: piece.color };
                    move.promotion = promotedPiece;
                }
                
                // Обновляем взятые фигуры
                if (capturedPiece && !move.enPassant) {
                    if (piece.color === 'white') {
                        this.capturedPieces.black.push(capturedPiece);
                    } else {
                        this.capturedPieces.white.push(capturedPiece);
                    }
                }
                
                // Обновляем права на рокировку
                if (piece.type === 'k') {
                    this.castlingRights[piece.color].king = false;
                }
                if (piece.type === 'r') {
                    if (fromCol === 0) this.castlingRights[piece.color].queenside = false;
                    if (fromCol === 7) this.castlingRights[piece.color].kingside = false;
                }
                
                // Устанавливаем en passant для следующего хода
                this.enPassantSquare = null;
                if (piece.type === 'p' && Math.abs(toRow - fromRow) === 2) {
                    this.enPassantSquare = [
                        fromRow + (toRow - fromRow) / 2,
                        fromCol
                    ];
                }
                
                // Обновляем счётчик ходов
                this.halfMoveClock++;
                if (piece.type === 'p' || capturedPiece) {
                    this.halfMoveClock = 0;
                }
                
                if (piece.color === 'black') {
                    this.fullMoveNumber++;
                }
                
                // Добавляем ход в историю
                this.moveHistory.push(move);
                
                // Меняем игрока
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Проверяем состояние игры
                this.checkGameState();
                
                return true;
            }
            
            checkGameState() {
                const color = this.currentPlayer === 'white' ? 'black' : 'white';
                const opponentColor = this.currentPlayer;
                
                // Находим короля текущего игрока
                let kingRow, kingCol;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.type === 'k' && piece.color === color) {
                            kingRow = r;
                            kingCol = c;
                            break;
                        }
                    }
                }
                
                // Проверяем шах
                const inCheck = this.isSquareAttacked(kingRow, kingCol, color);
                
                // Проверяем есть ли легальные ходы
                let hasLegalMoves = false;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.color === color) {
                            const moves = this.getValidMoves(r, c);
                            if (moves.length > 0) {
                                hasLegalMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasLegalMoves) break;
                }
                
                if (!hasLegalMoves) {
                    if (inCheck) {
                        this.gameState = 'checkmate';
                    } else {
                        this.gameState = 'stalemate';
                    }
                } else if (inCheck) {
                    this.gameState = 'check';
                } else {
                    this.gameState = 'playing';
                }
                
                // Проверка на пат (50 ходов без взятия или движения пешки)
                if (this.halfMoveClock >= 100) {
                    this.gameState = 'draw';
                }
            }
            
            undoMove() {
                if (this.moveHistory.length === 0) return false;
                
                const lastMove = this.moveHistory.pop();
                const { from, to, piece, captured, promotion, castling, enPassant } = lastMove;
                
                // Возвращаем фигуру на место
                this.board[from[0]][from[1]] = piece;
                
                // Если было превращение пешки, возвращаем пешку
                if (promotion) {
                    this.board[from[0]][from[1]] = { type: 'p', color: piece.color };
                }
                
                // Возвращаем взятую фигуру
                if (captured) {
                    this.board[to[0]][to[1]] = captured;
                    
                    // Удаляем из списка взятых
                    const capturedArray = piece.color === 'white' ? 
                        this.capturedPieces.black : this.capturedPieces.white;
                    const index = capturedArray.findIndex(p => 
                        p.type === captured.type && p.color === captured.color
                    );
                    if (index !== -1) {
                        capturedArray.splice(index, 1);
                    }
                } else {
                    this.board[to[0]][to[1]] = null;
                }
                
                // Отмена рокировки
                if (castling) {
                    const color = piece.color;
                    const row = from[0];
                    
                    if (to[1] > from[1]) { // Короткая рокировка
                        this.board[row][5] = null;
                        this.board[row][7] = { type: 'r', color: color };
                        this.castlingRights[color].king = true;
                        this.castlingRights[color].kingside = true;
                    } else { // Длинная рокировка
                        this.board[row][3] = null;
                        this.board[row][0] = { type: 'r', color: color };
                        this.castlingRights[color].king = true;
                        this.castlingRights[color].queenside = true;
                    }
                }
                
                // Отмена взятия на проходе
                if (enPassant) {
                    const capturedRow = from[0];
                    const capturedCol = to[1];
                    this.board[capturedRow][capturedCol] = captured;
                    
                    const capturedArray = piece.color === 'white' ? 
                        this.capturedPieces.black : this.capturedPieces.white;
                    const index = capturedArray.findIndex(p => 
                        p.type === captured.type && p.color === captured.color
                    );
                    if (index !== -1) {
                        capturedArray.splice(index, 1);
                    }
                }
                
                // Возвращаем предыдущего игрока
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Сбрасываем состояние игры
                this.gameState = 'playing';
                
                return true;
            }
            
            getBestMove(difficulty = 1) {
                const color = this.currentPlayer;
                const allMoves = [];
                
                // Собираем все возможные ходы
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && piece.color === color) {
                            const moves = this.getValidMoves(r, c);
                            for (const [toRow, toCol] of moves) {
                                allMoves.push({
                                    from: [r, c],
                                    to: [toRow, toCol],
                                    piece: piece
                                });
                            }
                        }
                    }
                }
                
                if (allMoves.length === 0) return null;
                
                // Оцениваем каждый ход
                const evaluatedMoves = allMoves.map(move => {
                    const score = this.evaluateMove(move, difficulty);
                    return { ...move, score };
                });
                
                // Сортируем по оценке (для чёрных - обратный порядок)
                evaluatedMoves.sort((a, b) => {
                    return color === 'white' ? b.score - a.score : a.score - b.score;
                });
                
                // Выбираем лучший ход с учётом сложности
                let bestMoves;
                if (difficulty === 1) { // Легко - иногда делает ошибки
                    bestMoves = evaluatedMoves.slice(-5); // Выбираем из худших
                } else if (difficulty === 2) { // Средне
                    bestMoves = evaluatedMoves.slice(0, Math.ceil(evaluatedMoves.length / 2));
                } else { // Сложно - всегда лучший ход
                    bestMoves = evaluatedMoves.slice(0, 3);
                }
                
                // Случайный выбор из лучших ходов
                const randomIndex = Math.floor(Math.random() * bestMoves.length);
                return bestMoves[randomIndex];
            }
            
            evaluateMove(move, difficulty) {
                let score = 0;
                const { from, to, piece } = move;
                const targetPiece = this.board[to[0]][to[1]];
                
                // Материальная ценность фигур
                const pieceValues = {
                    'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000
                };
                
                // Взятие фигуры
                if (targetPiece) {
                    score += pieceValues[targetPiece.type] * (difficulty + 1);
                }
                
                // Центральные клетки ценнее для пешек и коней
                const centerControl = this.getCenterControl(to[0], to[1], piece.type);
                score += centerControl * difficulty;
                
                // Безопасность короля
                if (piece.type === 'k') {
                    const safety = this.getKingSafety(to[0], to[1], piece.color);
                    score += safety * difficulty;
                }
                
                // Развитие фигур (для начала игры)
                if (this.fullMoveNumber < 10) {
                    if ((piece.type === 'n' || piece.type === 'b') && 
                        (from[0] === 0 || from[0] === 7)) {
                        score += 50 * difficulty;
                    }
                }
                
                return score;
            }
            
            getCenterControl(row, col, pieceType) {
                // Центральные клетки
                const centerSquares = [[3,3], [3,4], [4,3], [4,4]];
                const extendedCenter = [
                    [2,2], [2,3], [2,4], [2,5],
                    [3,2], [3,3], [3,4], [3,5],
                    [4,2], [4,3], [4,4], [4,5],
                    [5,2], [5,3], [5,4], [5,5]
                ];
                
                for (const [cr, cc] of centerSquares) {
                    if (row === cr && col === cc) {
                        return pieceType === 'p' ? 30 : 20;
                    }
                }
                
                for (const [cr, cc] of extendedCenter) {
                    if (row === cr && col === cc) {
                        return pieceType === 'p' ? 15 : 10;
                    }
                }
                
                return 0;
            }
            
            getKingSafety(row, col, color) {
                // Король должен стремиться к рокировке и избегать центра
                if (this.fullMoveNumber < 15) {
                    if (col === 6 || col === 2) return 50; // Позиции для рокировки
                    if (col >= 3 && col <= 5) return -30; // Центр опасен
                } else {
                    // В эндшпиле король должен быть активным
                    if (row >= 2 && row <= 5 && col >= 2 && col <= 5) return 20;
                }
                return 0;
            }
        }
        
        // Игровой интерфейс
        class ChessGame {
            constructor() {
                this.engine = new ChessEngine();
                this.gameMode = 'ai'; // ai, local, online
                this.difficulty = 1;
                this.playerColor = 'white';
                this.timeControl = 600; // секунды
                this.whiteTime = 600;
                this.blackTime = 600;
                this.timerInterval = null;
                this.isFlipped = false;
                this.promotionCallback = null;
                
                this.initUI();
                this.setupEventListeners();
                this.renderBoard();
                this.updateGameInfo();
            }
            
            initUI() {
                this.elements = {
                    chessboard: document.getElementById('chessboard'),
                    boardGrid: document.getElementById('boardGrid'),
                    whiteTime: document.getElementById('whiteTime'),
                    blackTime: document.getElementById('blackTime'),
                    whiteCaptured: document.getElementById('whiteCaptured'),
                    blackCaptured: document.getElementById('blackCaptured'),
                    statusMessage: document.getElementById('statusMessage'),
                    movesContainer: document.getElementById('movesContainer'),
                    currentTurn: document.getElementById('currentTurn'),
                    currentPlayer: document.getElementById('currentPlayer'),
                    promotionModal: document.getElementById('promotionModal'),
                    promotionOptions: document.getElementById('promotionOptions'),
                    whitePlayer: document.getElementById('whitePlayer'),
                    blackPlayer: document.getElementById('blackPlayer'),
                    startGame: document.getElementById('startGame'),
                    newGame: document.getElementById('newGame'),
                    undoBtn: document.getElementById('undoBtn'),
                    hintBtn: document.getElementById('hintBtn'),
                    flipBtn: document.getElementById('flipBtn')
                };
            }
            
            setupEventListeners() {
                // Режимы игры
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.gameMode = btn.dataset.mode;
                        
                        // Показываем/скрываем онлайн панель
                        const onlinePanel = document.getElementById('onlinePanel');
                        onlinePanel.style.display = this.gameMode === 'online' ? 'block' : 'none';
                        
                        this.updateStatusMessage(`Режим: ${btn.querySelector('.mode-title').textContent}`);
                    });
                });
                
                // Сложность
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (!btn.dataset.level) return;
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.difficulty = parseInt(btn.dataset.level);
                    });
                });
                
                // Цвет
                document.querySelectorAll('.difficulty-btn[data-color]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-btn[data-color]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.playerColor = btn.dataset.color;
                        if (this.playerColor === 'random') {
                            this.playerColor = Math.random() > 0.5 ? 'white' : 'black';
                        }
                        
                        // Обновляем отображение доски
                        this.isFlipped = this.playerColor === 'black';
                        this.renderBoard();
                    });
                });
                
                // Контроль времени
                document.getElementById('timeControl').addEventListener('change', (e) => {
                    this.timeControl = parseInt(e.target.value);
                    this.whiteTime = this.timeControl;
                    this.blackTime = this.timeControl;
                    this.updateTimers();
                });
                
                // Кнопки управления
                this.elements.startGame.addEventListener('click', () => this.startGame());
                this.elements.newGame.addEventListener('click', () => this.resetGame());
                this.elements.undoBtn.addEventListener('click', () => this.undoMove());
                this.elements.hintBtn.addEventListener('click', () => this.showHint());
                this.elements.flipBtn.addEventListener('click', () => this.flipBoard());
                
                // Онлайн кнопки
                document.getElementById('copyRoomCode')?.addEventListener('click', () => this.copyRoomCode());
                document.getElementById('shareRoom')?.addEventListener('click', () => this.shareRoom());
            }
            
            renderBoard() {
                this.elements.boardGrid.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        
                        // Учитываем поворот доски
                        const displayRow = this.isFlipped ? 7 - row : row;
                        const displayCol = this.isFlipped ? 7 - col : col;
                        
                        // Координаты
                        if ((this.isFlipped && row === 0) || (!this.isFlipped && row === 7)) {
                            const fileCoord = document.createElement('div');
                            fileCoord.className = 'coordinates coordinate-file';
                            fileCoord.textContent = String.fromCharCode(97 + displayCol);
                            square.appendChild(fileCoord);
                        }
                        
                        if ((this.isFlipped && col === 7) || (!this.isFlipped && col === 0)) {
                            const rankCoord = document.createElement('div');
                            rankCoord.className = 'coordinates coordinate-rank';
                            rankCoord.textContent = (8 - displayRow).toString();
                            square.appendChild(rankCoord);
                        }
                        
                        // Фигура
                        const piece = this.engine.board[displayRow][displayCol];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${this.engine.getPieceColorClass(piece)}`;
                            pieceElement.dataset.row = displayRow;
                            pieceElement.dataset.col = displayCol;
                            
                            // Используем Unicode символы для фигур с правильными цветами
                            const symbol = this.engine.getPieceSymbol(piece);
                            pieceElement.textContent = symbol;
                            pieceElement.style.fontSize = '40px';
                            pieceElement.style.display = 'flex';
                            pieceElement.style.alignItems = 'center';
                            pieceElement.style.justifyContent = 'center';
                            pieceElement.style.cursor = 'pointer';
                            pieceElement.style.fontWeight = 'bold';
                            
                            square.appendChild(pieceElement);
                        }
                        
                        // Подсветка выбранной клетки
                        if (this.engine.selectedSquare && 
                            this.engine.selectedSquare[0] === displayRow && 
                            this.engine.selectedSquare[1] === displayCol) {
                            square.classList.add('selected');
                        }
                        
                        // Подсветка валидных ходов
                        if (this.engine.selectedSquare) {
                            const [selectedRow, selectedCol] = this.engine.selectedSquare;
                            if (selectedRow === displayRow && selectedCol === displayCol) {
                                square.classList.add('selected');
                            }
                            
                            this.engine.validMoves.forEach(([moveRow, moveCol]) => {
                                if (moveRow === displayRow && moveCol === displayCol) {
                                    const targetPiece = this.engine.board[moveRow][moveCol];
                                    if (targetPiece) {
                                        square.classList.add('capture-move');
                                    } else {
                                        square.classList.add('valid-move');
                                    }
                                }
                            });
                        }
                        
                        // Подсветка последнего хода
                        if (this.engine.moveHistory.length > 0) {
                            const lastMove = this.engine.moveHistory[this.engine.moveHistory.length - 1];
                            if ((lastMove.from[0] === displayRow && lastMove.from[1] === displayCol) ||
                                (lastMove.to[0] === displayRow && lastMove.to[1] === displayCol)) {
                                square.classList.add('last-move');
                            }
                        }
                        
                        // Обработка кликов
                        square.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.handleSquareClick(displayRow, displayCol);
                        });
                        
                        // Drag and drop
                        square.addEventListener('dragover', (e) => {
                            e.preventDefault();
                        });
                        
                        square.addEventListener('drop', (e) => {
                            e.preventDefault();
                            const data = e.dataTransfer.getData('text/plain');
                            const [fromRow, fromCol] = data.split(',').map(Number);
                            this.handleSquareClick(fromRow, fromCol); // Выбираем фигуру
                            this.handleSquareClick(displayRow, displayCol); // Делаем ход
                        });
                        
                        this.elements.boardGrid.appendChild(square);
                    }
                }
                
                // Добавляем drag and drop для фигур
                document.querySelectorAll('.piece').forEach(piece => {
                    piece.setAttribute('draggable', 'true');
                    
                    piece.addEventListener('dragstart', (e) => {
                        const row = piece.dataset.row;
                        const col = piece.dataset.col;
                        e.dataTransfer.setData('text/plain', `${row},${col}`);
                        piece.classList.add('dragging');
                    });
                    
                    piece.addEventListener('dragend', () => {
                        piece.classList.remove('dragging');
                    });
                });
                
                // Правый клик для отмены выбора
                this.elements.chessboard.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.engine.selectedSquare = null;
                    this.engine.validMoves = [];
                    this.renderBoard();
                });
            }
            
            handleSquareClick(row, col) {
                const moveMade = this.engine.selectSquare(row, col);
                this.renderBoard();
                
                if (moveMade) {
                    this.updateGameInfo();
                    
                    // Проверяем превращение пешки
                    const piece = this.engine.board[row][col];
                    if (piece && piece.type === 'p' && (row === 0 || row === 7)) {
                        this.showPromotionModal(row, col, piece.color);
                    } else {
                        this.afterMove();
                    }
                }
            }
            
            showPromotionModal(row, col, pieceColor) {
                this.elements.promotionModal.style.display = 'block';
                this.elements.promotionOptions.innerHTML = '';
                
                const promotionPieces = [
                    { type: 'q', symbol: '♕', name: 'Ферзь' },
                    { type: 'r', symbol: '♖', name: 'Ладья' },
                    { type: 'b', symbol: '♗', name: 'Слон' },
                    { type: 'n', symbol: '♘', name: 'Конь' }
                ];
                
                promotionPieces.forEach(promo => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `promotion-piece ${pieceColor}`;
                    pieceElement.dataset.piece = promo.type;
                    pieceElement.textContent = pieceColor === 'white' ? 
                        promo.symbol.toUpperCase() : 
                        promo.symbol.toLowerCase();
                    pieceElement.title = promo.name;
                    
                    pieceElement.addEventListener('click', () => {
                        const promotionType = pieceElement.dataset.piece;
                        const lastMove = this.engine.moveHistory[this.engine.moveHistory.length - 1];
                        this.engine.makeMove(lastMove.from[0], lastMove.from[1], lastMove.to[0], lastMove.to[1], promotionType);
                        this.elements.promotionModal.style.display = 'none';
                        this.renderBoard();
                        this.updateGameInfo();
                        this.afterMove();
                    });
                    
                    this.elements.promotionOptions.appendChild(pieceElement);
                });
            }
            
            afterMove() {
                this.updateStatusMessage();
                this.updateCapturedPieces();
                
                // Если игра против AI и сейчас ход AI
                if (this.gameMode === 'ai' && 
                    this.engine.currentPlayer !== this.playerColor &&
                    this.engine.gameState === 'playing') {
                    
                    // Запускаем ход AI через небольшую задержку
                    setTimeout(() => {
                        this.makeAIMove();
                    }, 500);
                }
                
                // Обновляем активного игрока в UI
                this.updateActivePlayer();
            }
            
            makeAIMove() {
                const bestMove = this.engine.getBestMove(this.difficulty);
                if (bestMove) {
                    const { from, to, piece } = bestMove;
                    this.engine.makeMove(from[0], from[1], to[0], to[1]);
                    this.renderBoard();
                    this.updateGameInfo();
                    
                    // Проверяем превращение пешки (AI всегда выбирает ферзя)
                    const newPiece = this.engine.board[to[0]][to[1]];
                    if (newPiece && newPiece.type === 'p' && (to[0] === 0 || to[0] === 7)) {
                        this.engine.makeMove(from[0], from[1], to[0], to[1], 'q');
                        this.renderBoard();
                    }
                    
                    this.afterMove();
                }
            }
            
            startGame() {
                this.resetGame();
                this.updateStatusMessage('Игра началась!');
                
                // Запускаем таймер
                this.startTimer();
                
                // Если играем против AI и мы играем чёрными, AI ходит первым
                if (this.gameMode === 'ai' && this.playerColor === 'black') {
                    setTimeout(() => {
                        this.makeAIMove();
                    }, 1000);
                }
            }
            
            resetGame() {
                this.engine = new ChessEngine();
                this.whiteTime = this.timeControl;
                this.blackTime = this.timeControl;
                
                // Останавливаем таймер
                this.stopTimer();
                
                // Сбрасываем UI
                this.renderBoard();
                this.updateGameInfo();
                this.updateCapturedPieces();
                this.updateStatusMessage('Новая игра. Начните ход!');
                this.updateActivePlayer();
                
                // Обновляем цвет игрока если нужно
                if (this.playerColor === 'black') {
                    this.isFlipped = true;
                    this.renderBoard();
                }
            }
            
            startTimer() {
                this.stopTimer(); // Останавливаем предыдущий таймер
                
                this.timerInterval = setInterval(() => {
                    if (this.engine.currentPlayer === 'white') {
                        this.whiteTime = Math.max(0, this.whiteTime - 1);
                    } else {
                        this.blackTime = Math.max(0, this.blackTime - 1);
                    }
                    
                    this.updateTimers();
                    
                    // Проверка на флаг
                    if (this.whiteTime === 0 || this.blackTime === 0) {
                        this.stopTimer();
                        const winner = this.whiteTime === 0 ? 'Чёрные' : 'Белые';
                        this.updateStatusMessage(`${winner} выиграли по времени!`, 'checkmate');
                    }
                }, 1000);
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            
            updateTimers() {
                const formatTime = (seconds) => {
                    const mins = Math.floor(seconds / 60);
                    const secs = seconds % 60;
                    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                };
                
                this.elements.whiteTime.textContent = formatTime(this.whiteTime);
                this.elements.blackTime.textContent = formatTime(this.blackTime);
                
                // Подсветка при малом времени
                this.elements.whiteTime.classList.toggle('low', this.whiteTime < 30 && this.whiteTime > 0);
                this.elements.blackTime.classList.toggle('low', this.blackTime < 30 && this.blackTime > 0);
            }
            
            updateGameInfo() {
                // Обновляем номер хода
                const moveNumber = Math.ceil(this.engine.moveHistory.length / 2) + 1;
                this.elements.currentTurn.textContent = moveNumber;
                
                // Обновляем текущего игрока
                this.elements.currentPlayer.textContent = 
                    this.engine.currentPlayer === 'white' ? 'Белые' : 'Чёрные';
                
                // Обновляем список ходов
                this.updateMoveList();
                
                // Обновляем статус
                this.updateStatusMessage();
            }
            
            updateMoveList() {
                this.elements.movesContainer.innerHTML = '';
                
                for (let i = 0; i < this.engine.moveHistory.length; i += 2) {
                    const moveNumber = Math.floor(i / 2) + 1;
                    const whiteMove = this.engine.moveHistory[i];
                    const blackMove = this.engine.moveHistory[i + 1];
                    
                    const moveElement = document.createElement('div');
                    moveElement.style.gridColumn = '1 / -1';
                    moveElement.style.display = 'grid';
                    moveElement.style.gridTemplateColumns = '50px 1fr 1fr';
                    moveElement.style.gap = '5px';
                    moveElement.style.marginBottom = '5px';
                    
                    // Номер хода
                    const numberSpan = document.createElement('span');
                    numberSpan.textContent = moveNumber + '.';
                    numberSpan.style.fontWeight = '600';
                    numberSpan.style.color = 'var(--text-secondary)';
                    
                    // Ход белых
                    const whiteSpan = document.createElement('span');
                    whiteSpan.textContent = this.getMoveNotation(whiteMove);
                    whiteSpan.className = 'move-item';
                    whiteSpan.style.textAlign = 'center';
                    
                    if (i === this.engine.moveHistory.length - 1) {
                        whiteSpan.classList.add('current');
                    }
                    
                    // Ход чёрных
                    const blackSpan = document.createElement('span');
                    if (blackMove) {
                        blackSpan.textContent = this.getMoveNotation(blackMove);
                        blackSpan.className = 'move-item';
                        blackSpan.style.textAlign = 'center';
                        
                        if (i + 1 === this.engine.moveHistory.length - 1) {
                            blackSpan.classList.add('current');
                        }
                    }
                    
                    moveElement.appendChild(numberSpan);
                    moveElement.appendChild(whiteSpan);
                    moveElement.appendChild(blackSpan);
                    this.elements.movesContainer.appendChild(moveElement);
                }
            }
            
            getMoveNotation(move) {
                const { from, to, piece, captured, promotion, castling } = move;
                const files = 'abcdefgh';
                const ranks = '87654321';
                
                if (castling) {
                    return to[1] > from[1] ? 'O-O' : 'O-O-O';
                }
                
                let notation = '';
                
                // Для пешки просто указываем взятие или ход
                if (piece.type === 'p') {
                    if (captured) {
                        notation += files[from[1]] + 'x';
                    }
                } else {
                    // Для других фигур указываем тип
                    const pieceSymbol = {
                        'n': 'N', 'b': 'B', 'r': 'R', 'q': 'Q', 'k': 'K'
                    }[piece.type];
                    notation += pieceSymbol;
                }
                
                notation += files[to[1]] + ranks[to[0]];
                
                if (promotion) {
                    const promoSymbol = {
                        'q': 'Q', 'r': 'R', 'b': 'B', 'n': 'N'
                    }[promotion];
                    notation += '=' + promoSymbol;
                }
                
                return notation;
            }
            
            updateStatusMessage(customMessage = null, type = null) {
                if (customMessage) {
                    this.elements.statusMessage.textContent = customMessage;
                    this.elements.statusMessage.className = 'status-message';
                    if (type) {
                        this.elements.statusMessage.classList.add(type);
                    }
                    return;
                }
                
                let message = '';
                let className = 'status-message';
                
                switch (this.engine.gameState) {
                    case 'checkmate':
                        const winner = this.engine.currentPlayer === 'white' ? 'Чёрные' : 'Белые';
                        message = `Мат! Победили ${winner}`;
                        className += ' checkmate';
                        this.stopTimer();
                        break;
                    case 'stalemate':
                        message = 'Пат! Ничья';
                        className += ' stalemate';
                        this.stopTimer();
                        break;
                    case 'check':
                        message = 'Шах!';
                        className += ' check';
                        break;
                    case 'draw':
                        message = 'Ничья (правило 50 ходов)';
                        className += ' stalemate';
                        this.stopTimer();
                        break;
                    case 'playing':
                        message = `Ходят ${this.engine.currentPlayer === 'white' ? 'белые' : 'чёрные'}`;
                        break;
                    default:
                        message = 'Готов к игре';
                }
                
                this.elements.statusMessage.textContent = message;
                this.elements.statusMessage.className = className;
            }
            
            updateCapturedPieces() {
                this.elements.whiteCaptured.innerHTML = '';
                this.elements.blackCaptured.innerHTML = '';
                
                // Сортируем взятые фигуры по ценности
                const pieceOrder = ['q', 'r', 'b', 'n', 'p'];
                
                this.engine.capturedPieces.white.sort((a, b) => 
                    pieceOrder.indexOf(a.type) - pieceOrder.indexOf(b.type)
                );
                
                this.engine.capturedPieces.black.sort((a, b) => 
                    pieceOrder.indexOf(a.type) - pieceOrder.indexOf(b.type)
                );
                
                // Отображаем взятые фигуры белых (чёрные фигуры)
                this.engine.capturedPieces.white.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `captured-piece black`;
                    pieceElement.textContent = this.engine.getPieceSymbol(piece);
                    pieceElement.title = this.getPieceName(piece);
                    this.elements.whiteCaptured.appendChild(pieceElement);
                });
                
                // Отображаем взятые фигуры чёрных (белые фигуры)
                this.engine.capturedPieces.black.forEach(piece => {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `captured-piece white`;
                    pieceElement.textContent = this.engine.getPieceSymbol(piece);
                    pieceElement.title = this.getPieceName(piece);
                    this.elements.blackCaptured.appendChild(pieceElement);
                });
            }
            
            getPieceName(piece) {
                const names = {
                    'k': 'Король', 'q': 'Ферзь', 'r': 'Ладья', 
                    'b': 'Слон', 'n': 'Конь', 'p': 'Пешка'
                };
                return names[piece.type];
            }
            
            updateActivePlayer() {
                const isWhiteActive = this.engine.currentPlayer === 'white';
                
                this.elements.whitePlayer.classList.toggle('active', isWhiteActive);
                this.elements.blackPlayer.classList.toggle('active', !isWhiteActive);
            }
            
            undoMove() {
                if (this.engine.moveHistory.length === 0) return;
                
                const undone = this.engine.undoMove();
                if (undone) {
                    // Если игра против AI, отменяем два хода (ход игрока и ход AI)
                    if (this.gameMode === 'ai') {
                        this.engine.undoMove();
                    }
                    
                    this.renderBoard();
                    this.updateGameInfo();
                    this.updateStatusMessage('Ход отменён');
                }
            }
            
            showHint() {
                if (this.engine.gameState !== 'playing' || 
                    this.engine.currentPlayer !== this.playerColor) {
                    showNotification('Подсказка доступна только во время вашего хода', 'info');
                    return;
                }
                
                const bestMove = this.engine.getBestMove(this.difficulty);
                if (bestMove) {
                    const { from, to } = bestMove;
                    this.engine.selectedSquare = from;
                    this.engine.validMoves = [to];
                    this.renderBoard();
                    
                    // Сбрасываем через 3 секунды
                    setTimeout(() => {
                        this.engine.selectedSquare = null;
                        this.engine.validMoves = [];
                        this.renderBoard();
                    }, 3000);
                    
                    showNotification('Подсказка показана (зелёная точка)', 'info');
                }
            }
            
            flipBoard() {
                this.isFlipped = !this.isFlipped;
                this.renderBoard();
            }
            
            copyRoomCode() {
                const roomCode = document.getElementById('roomCode').textContent;
                navigator.clipboard.writeText(roomCode)
                    .then(() => showNotification('Код комнаты скопирован!', 'success'))
                    .catch(() => showNotification('Не удалось скопировать код', 'error'));
            }
            
            shareRoom() {
                const roomCode = document.getElementById('roomCode').textContent;
                const shareText = `Присоединяйтесь к моей шахматной комнате! Код: ${roomCode}\n\nСсылка: ${window.location.href}`;
                
                if (navigator.share) {
                    navigator.share({
                        title: 'Шахматная комната',
                        text: shareText
                    });
                } else {
                    navigator.clipboard.writeText(shareText)
                        .then(() => showNotification('Приглашение скопировано!', 'success'))
                        .catch(() => showNotification('Не удалось скопировать приглашение', 'error'));
                }
            }
        }
        
        // Уведомления
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        // Запуск игры при загрузке страницы
        document.addEventListener('DOMContentLoaded', () => {
            window.chessGame = new ChessGame();
            showNotification('Шахматы готовы! Выберите режим и начните игру.', 'success');
        });
    </script>
</body>
</html>
